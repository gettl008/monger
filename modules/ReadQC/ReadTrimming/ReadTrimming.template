#!/usr/bin/env bash
#define MAX_ARG_PAGES 32
set -e
export SHELL=$(type -p bash)
freemem=`free | awk '{print $4}'`
freemem=`echo $freemem | cut -d' ' -f4`
MEMLIMIT=`expr $freemem \/ 4 \* 3`
export _JAVA_OPTIONS=-Xmx2g
###############################################
MODULE_NAME=`basename "$0" | tr "[a-z]" "[A-Z]"`
module_name=`basename "$0" | tr "[A-Z]" "[a-z]"`
function beginswith { 
	case $2 in 
		"$1"*) true;; 
		*) false;; 
	esac
}
###############################################
###################
### MODULE INFO ###
###################
DESCRIPTION=
WEBSITE=
CITATIONS=
MODULE_AUTHOR=
YEAR_WRITTEN=
###############################################
MODULE_INFO="DESCRIPTION:\n$DESCRIPTION\nWEBSITE:\n$WEBSITE\nCITATION:\n$CITATION"
AUTHOR_INFO="$MODULE_AUTHOR $YEAR_WRITTEN"

function mongerinstall {
	MODULE_NAME=$1
	shift
	MODULE_INFO=$1
	shift
	AUTHOR_INFO=$1
	shift
	module_name=`echo $MODULE_NAME | tr "[A-Z]" "[a-z]"`
	SUBTHREADS=1
	####################################
	############ USAGE #################
	####################################
	usage="SYNOPSIS:\nmonger install $module_name\n$MODULE_INFO\n\
OPTIONS:\n\
  -i | --install_dir [DIR]\tInstallation directory [/usr/local/]\n\
  -f | --force\t\t\tOverwrite existing program executables.\n\	
  -h | --help\t\t\tPrint help message\n\n\
AUTHOR:\n\
$AUTHOR_INFO"

	####################################
	######## INPUT PROCESSING ##########
	####################################
	INSTALL_DIR=/usr/local
	FORCE=FALSE
	while [ "$1" != "" ]
	do
		case $1 in
			-i | --install_dir)	
				shift
				INSTALL_DIR=$1;;
			-f | --force)
				FORCE=TRUE;;
			-h | --help)
				echo -e $usage
				exit 1;;
			*)	
				echo -e "\nMONGER RUN $MODULE_NAME ERROR: $1 is not a valid option.\n$usage"
				exit 1				
		esac
		shift
	done

	####################################

	PATH_SEP=`echo $PATH | sed 's|:| |g'`
	LD_LIBRARY_PATH_SEP=`echo $LD_LIBRARY_PATH | sed 's|:| |g'`
	INCLUDE_SEP=`echo $INCLUDE | sed 's|:| |g'`

	cur_dir=`pwd`
	DOWNLOAD_DIR=$INSTALL_DIR/soft
	mkdir -p $DOWNLOAD_DIR

	####################################
	####### INSTALL DEPENDENCIES #######
	####################################

	###############################################

	####################################
	####### INSTALL MAIN PROGRAM #######
	####################################

	##########
	# XXXXXX #
	##########
	if ! type "xxxxx" >/dev/null 2>/dev/null || [ $FORCE == "TRUE" ]
	then
		echo -e "> MONGER INSTALL: Installing $MODULE_NAME."
		cd $DOWNLOAD_DIR
		##############################
		rm -rf $DOWNLOAD_DIR/xxxxx
		cd $DOWNLOAD_DIR/adapterremoval
		make
		make install PREFIX=$INSTALL_DIR
		##############################
	else
		echo "> MONGER INSTALL: $MODULE_NAME already installed. Skipping..."
	fi

}
function run {
	MODULE_NAME=$1
	shift
	MODULE_INFO=$1
	shift
	AUTHOR_INFO=$1
	shift
	module_name=`echo $MODULE_NAME | tr "[A-Z]" "[a-z]"`
	SUBTHREADS=1
	####################################
	########### FUNCTIONS ##############
	####################################

	function time_elapsed {
		end_time=`date +%s`
		elapsed_secs=`expr $end_time - $1`
		date -u -d @${elapsed_secs} +"%T"
	}
	
	####################################
	############ USAGE #################
	####################################
	usage="SYNOPSIS:\nmonger run $module_name\n$MODULE_INFO\n\
OPTIONS:\n\
  -1 | --input1\t[FILE]\tFASTQ input to evaluate.\n\
  -2 | --input2\t[FILE]\tFASTQ input (if paired-end)\n\
  -3 | --input3\t[FILE]\tUnpaired FASTQ reads\n\
  -n | --name\t[STR]\tSample name (basename of outputs)\n\
  -o | --outdir\t[DIR]\tOutput directory\n\
  -t | --threads\n\
  -A | --args\t[STR]\tArguments specified as variables in a bash file.\n\
  -f | --force\t\t\tOverwrite existing files.\n\
  -a | --adapters\t[FASTA]\tFASTA file containing adapter sequences.\n\
  --identify_adapters\t[BOOL]\tUse AdapterRemoval to find adapter sequences.[FALSE]\n\
  --trim_adapters\t[BOOL]\tIdentify and trim adapter sequences.[TRUE]\n\
  --trim_ends\t[BOOL]\tTrim low quality ends or Ns at the ends of reads.[FALSE]\n\
  -q | --min_quality\t[INT]\tMinimum quality allowed before trimming if '--trim_ends' is true.[3]\n\
  -m | --min_length\t[INT]\tDiscard trimmed reads smaller than this.[15] \n\
  -N | --max_Ns\t[INT]\tMaximum allowable number of ambiguous bp's in a read before discarding.[50]\n\
  -c | --collapse\t\t\tCollapse overlapping paired-end reads into single read.\n\
  -u | --unpaired\t\t\tOutput unpaired singleton reads when using in a pipeline.\n\
  -h | --help\t\t\tPrint help message\n\n\
AUTHOR:\n\
$AUTHOR_INFO"

	####################################
	######## INPUT PROCESSING ##########
	####################################
	FORCE=FALSE
	if [ $# -eq 0 ]
	then
		echo -e $usage
		exit 1
	fi

	#################
	# Program specific defaults
	adapter_path=ADAPTER_PATH
	identify_adapters=false
	trim_adapters=true
	trim_ends=false
	min_quality=3
	min_length=15
	max_Ns=50
	collapse=false
	unpaired=false
	#################
	while [ "$1" != "" ]
	do
		case $1 in
			-1 | --input1)
				if ! `beginswith "-" "$2"`
				then
					shift
					if ! test -f $1
					then
						echo -e "\nMONGER RUN $MODULE_NAME WARNING: Cannot find input file $1. Skipping...\n"
					else
						main_inputs=$1
					fi
				fi;;
			-2 | --input2)
				if ! `beginswith "-" "$2"`
				then
					shift
					if ! test -f $1
					then
						echo -e "\nMONGER RUN $MODULE_NAME WARNING: Cannot find input file $1. Skipping...\n"
					else
						main_inputs="$main_inputs $1"
					fi
				fi;;
			-3 | --input3)
				if ! `beginswith "-" "$2"`
				then
					shift
					if ! test -f $1
					then
						echo -e "\nMONGER RUN $MODULE_NAME WARNING: Cannot find input file $1. Skipping...\n"
					else
						unpaired_inputs=$1
					fi
				fi;;
			-I | --input_list)
				if ! `beginswith "-" "$2"`
				then
					shift
					if ! test -f $1
					then
						echo -e "\nMONGER RUN $MODULE_NAME ERROR: Cannot find input file list $1.\n"
						exit 1
					else
						input_list=$1
						field_num=`awk '{print NF}' $input_list`
						name=`awk -v last_field="$field_num" '{print $lastfield}' $input_list`
						index=1
						while [ $index -lt $field_num ]
						do
							input=`awk -v field="$index" '{print $field}' $input_list`
							if ! test -f "$input"
							then
								echo -e "\nMONGER RUN $MODULE_NAME WARNING: Cannot find input file $input. Skipping...\n"
							else
								inputs="$inputs $input"
								declare "in$index=$input"
							fi
							index=$(($index + 1))
						done
					fi
				fi;;	
			-n | --name)
				if ! `beginswith "-" "$2"`
				then
					shift
					name=$1
				fi;;
			-o | --outdir)
				if ! `beginswith "-" "$2"`
				then
					shift
					outdir=$1
					mkdir -p $outdir
					if ! test -d $outdir
					then
						echo -e "\nMONGER RUN $MODULE_NAME ERROR: Could not find or create output directory $outdir.\n"
						exit 1
					fi
				fi;;
			-t | --threads)
				if ! `beginswith "-" "$2"`
				then
					shift
					SUBTHREADS=$1
				fi;;
			-A | --args)
				shift
				. $1;;
			-f | --force)
				force=true;;
			# -m | --maxmem)
			# 	shift
			# 	maxmem=$1
			# 	export _JAVA_OPTIONS=-Xmx$maxmem;;
			# 	# ulimit -v $maxmem;;
			-h | --help)
				echo -e $usage
				exit 1;;
			*)
				echo -e "\nMONGER RUN $MODULE_NAME ERROR: $1 is not a valid option.\n$usage"
				exit 1;;
			# Trim specific args
			-a | --adapters)
				if ! `beginswith "-" "$2"`
				then
					adapters=$1
				fi;;
			--identify_adapters)
				if ! `beginswith "-" "$2"`
				then
					shift
					temp=`echo "$1" | tr '[A-Z]' '[a-z]'`
					if [ "$temp" == "true" ] || "$temp" == "false"
					then
						indentify_adapters=$temp
					fi
				fi;;
			--trim_adapters)
				if ! `beginswith "-" "$2"`
				then
					shift
					temp=`echo "$1" | tr '[A-Z]' '[a-z]'`
					if [ "$temp" == "true" ] || "$temp" == "false"
					then
						trim_adapters=$temp
					fi
				fi;;
			--trim_ends)
				if ! `beginswith "-" "$2"`
				then
					shift
					temp=`echo "$1" | tr '[A-Z]' '[a-z]'`
					if [ "$temp" == "true" ] || "$temp" == "false"
					then
						--trim_ends=$temp
					fi
				fi;;
			-q | --min_quality)
				if ! `beginswith "-" "$2"`
				then
					shift
					if [ "$1" -eq "$1" ] 2>/dev/null
					then
						min_quality=$1
					else
						echo -e "MONGER RUN $MONGER_NAME WARNING: Argument specified ($1) for \"--min_quality\" is not an integer. Using default..."
					fi
				fi;;
			-m | --min_length)
				if ! `beginswith "-" "$2"`
				then
					shift
					if [ "$1" -eq "$1" ] 2>/dev/null
					then
						min_length=$1
					else
						echo -e "MONGER RUN $MONGER_NAME WARNING: Argument specified ($1) for \"--min_length\" is not an integer. Using default..."
					fi
				fi;;
			-N | --max_Ns)
				if ! `beginswith "-" "$2"`
				then
					shift
					if [ "$1" -eq "$1" ] 2>/dev/null
					then
						max_Ns=$1
					else
						echo -e "MONGER RUN $MONGER_NAME WARNING: Argument specified ($1) for \"--max_Ns\" is not an integer. Using default..."
					fi
				fi;;
			-c | --collapse)
				collapse=true;;
			-u | --unpaired)
				unpaired=true;;
		esac
		shift
	done
	echo -e "$MODULE_NAME" > $outdir/log.txt
	
	if [ "$name" == "" ]
	then
		name=`echo $inputs | cut -d' ' -f1 | basename`
		name="${name%.*}"
	fi
	mkdir -p $outdir/logs
	mkdir -p $outdir/resume
	mkdir -p $outdir/program_logs
	log_file=$outdir/logs/$name.log.txt
	resume_file=$outdir/resume/$name.resume.txt
	program_log_file=$outdir/program_logs/$name.program_log.txt
	
	echo -e "$MODULE_NAME" > $log_file
	if ! test -f $resume_file || [ "$force" == "true" ]
	then
		echo "$MODULE_NAME" > $resume_file
	fi

	####################################
	########## MAIN PROGRAM ############
	####################################
	for input in main_inputs unpaired_inputs
	do
		current_inputs=${!input}
		# echo "$current_inputs"
		if [ `echo $current_inputs | wc -w` -eq 1 ]
		then
			ended=SE
			in1=$current_inputs
		elif [ `echo $current_inputs | wc -w` -eq 2 ]
		then
			ended=PE
			in1=`echo $current_inputs | cut -d" " -f1`
			in2=`echo $current_inputs | cut -d" " -f2`
		elif [ `echo $current_inputs | wc -w` -eq 0 ]
		then
			break
		else
			echo -e "MONGER RUN $MODULE_NAME WARNING: There appears to be more than two paired files. Using just the first two.\n"
			ended=PE
			in1=`echo $current_inputs | cut -d" " -f1`
			in2=`echo $current_inputs | cut -d" " -f2`
		fi
		for part in $current_inputs
		do
			part_base=`basename $part`
			current_basenames="$current_basenames $part_base"
		done
		combined_names=`echo $current_basenames | tr " " "_"`
		echo -e " INPUT:$combined_names.$ended" >> $outdir/log.txt
		# PROGRAM
		STEP_NAME=identify_adapters
		if [ "$identify_adapters" == "true" ] && [ "$ended" == "PE" ]
		then
			if [ "`grep "$STEP_NAME.$combined_names=complete" $outdir/resume.txt`" == "" ] || [ "$force" == "true" ]
			then
				# Process start time
				start=`date +%s`
				echo -e "MONGER RUN $MODULE_NAME: Beginning step $STEP_NAME for $combined_names."
				echo -e "$STEP_NAME:" >> $outdir/program_log.txt
				#################
				# Make sure program is installed
				if ! type "AdapterRemoval" >/dev/null 2>/dev/null 
				then
					monger install $MODULE_NAME
				fi
				#################
				# Program step command
				AdapterRemoval --identify-adapters --file1 $in1 --file 2 $in2 \
					> $outdir/$name.$ended.adapters.txt 2>&1
				adapter1=`grep "\-\-adapter1" $outdir/$name.$ended.adapters.txt | cut -d" " -f5`
				adapter2=`grep "\-\-adapter1" $outdir/$name.$ended.adapters.txt | cut -d" " -f5`
				echo -e ">adapter1\n$adapter1\n>adapter2\n$adapter2" > $outdir/$name.$ended.adapters.fa
				#################
				echo -e "MONGER RUN $MODULE_NAME: $STEP_NAME for $combined_names complete."
				elapsed=`time_elapsed $start`
				echo -e "  $STEP_NAME=$elapsed" >> $outdir/log.txt
				echo "$STEP_NAME.$combined_names=complete" >> $outdir/resume.txt
			else
				echo -e "MONGER RUN $MODULE_NAME: Step \"$STEP_NAME\" complete for file $combined_names. Skipping..."
			fi
			adapters=$outdir/$name.$ended.adapters.fa
		fi
		STEP_NAME=
		if [ "`grep "$STEP_NAME.$combined_names=complete" $outdir/resume.txt`" == "" ] || [ "$force" == "true" ]
		then
			# Process start time
			start=`date +%s`
			echo -e "MONGER RUN $MODULE_NAME: Beginning step $STEP_NAME for $combined_names."
			echo -e "$STEP_NAME:" >> $outdir/program_log.txt
			#####################################################################################
			# Make sure program is installed
			if ! type "xxx" >/dev/null 2>/dev/null 
			then
				monger install $MODULE_NAME
			fi
			# Change adapter input from fasta to format program can use
			if [ "$adapters" != "" ]
			then
				#####
			fi
			# Construct program arguments if not provided in mongerscript
			if [ "$trim_adapters" == "true" ] \
				&& ! `echo "$XXX_args" | grep -q "xxx"`
			then
				XXXX_args="$XXXX_args xxx"
			fi
			if [ "$trim_ends" == "true" ] \
				&& ! `echo "$XXX_args" | grep -q "xxx"`
			then
				XXXX_args="$XXXX_args xxx"
			fi
			if [ "$trim_ends" == "true" ] \
				&& ! `echo "$xxx_args" | grep -q "xxx"`
			then
				XXXX_args="$XXXX_args xxx"
			fi
			if [ "$trim_ends" == "true" ] \
				&& ! `echo "$XXX_args" | grep -q "xxx"`
			then
				XXXX_args="$XXXX_args xxx"
			fi
			if [ "$collapse" == "true" ] && [ "$ended" == "PE" ] \
				&& ! `echo "$adapterremoval_args" | grep -q "xxx"`
			then
				XXXX_args="$XXXX_args xxx"
			fi
			if ! `echo "$XXX_args" | grep -q "xxx"`
			then
				XXXX_args="$XXXX_args xxx"
			fi
			if ! `echo "$XXX_args" | grep -q "xxx"`
			then
				XXXX_args="$XXXX_args xxx"
			fi
			# Define how program takes in inputs
			program_inputs=$in1
			if [ "$ended" == "PE" ]
			then
				program_inputs="$program_inputs $in2"
			fi
			# Program command
			XXX \
				THREADS=$SUBTHREADS \
				QUALITY_BASE=$PHRED_BASE \
				OUTPUT_BASE=$outdir/$name.$ended \
				INPUTS=$program_inputs \
				OTHER_ARGS=$XXXX_args \
 				>> $outdir/program_log.txt 2>&1
			#####################################################################################
			echo -e "MONGER RUN $MODULE_NAME: $STEP_NAME for $combined_names complete."
			#################
			elapsed=`time_elapsed $start`
			echo -e "  $STEP_NAME=$elapsed" >> $outdir/log.txt
			echo "$STEP_NAME.$combined_names=complete" >> $outdir/resume.txt
		else
			echo -e "MONGER RUN $MODULE_NAME: Step \"$STEP_NAME\" complete for file $combined_names. Skipping..."
		fi
	done
	#####################################################################################
	# Output names:
	singletons="$outdir/$name.PE.xxx"
	collapsed="$outdir/$name.PE.xxx"
	pair1="$outdir/$name.PE.pair1.xxx"
	pair2="$outdir/$name.PE.pair2.xxx"
	single_end="$outdir/$name.SE.xxx"
	# Record output info for downstream modules
	if [ `echo $main_inputs | wc -w` -eq 2 ]
	then
		# Combine single-end outputs (unpaired reads) into on file for downstream use
		if test -f "$singletons"
		then
			cat $singletons > $outdir/$name.PE.unpaired
		fi
		if [ "$collapse" == "true" ] && test -f "$collapsed"
		then
			cat $collapsed >> $outdir/$name.PE.unpaired
		fi
		if [ "$unpaired_inputs" != "" ]
		then
			cat $single_end >> $outdir/$name.PE.unpaired
		fi
		if [ "$unpaired" == "true" ]
		then
			out3="$outdir/$name.PE.unpaired"
		else
			out3="-"
		fi
		# Add names of output paired and unpaired files to a textfile for downstream use
		echo -e "$pair1\t$pair2\t$out3\t$name" > $outdir/$name.outputs.txt
	else
		# Add names of single-end files to a textfile for downstream use
		echo -e "$single_end\t-\t-\t$name" >  $outdir/$name.outputs.txt
	fi
	echo -e "MONGER RUN $MODULE_NAME: Complete."
}

############################################################
if [ "$1" == "run" ]
then
	shift
	run "$MODULE_NAME" "$MODULE_INFO" "$AUTHOR_INFO" $*
elif [ "$1" == "install" ]
then
	shift
	mongerinstall "$MODULE_NAME" "$MODULE_INFO" "$AUTHOR_INFO" $*
else
	echo -e \
"SYNOPSIS:\n\
monger [run|install] $module_name\n$MODULE_INFO\n$AUTHOR_INFO"
	exit 1
fi